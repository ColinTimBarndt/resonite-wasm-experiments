using System;
using Elements.Core;
using Plugin.Wasm.Components;
using ProtoFlux.Core;
using ProtoFlux.Runtimes.Execution;

namespace Plugin.Wasm.ProtoFlux;

using FunctionExport = WebAssemblyInstance.FunctionExport;

/// <summary>
/// A base class for all WebAssembly ProtoFlux nodes.
/// </summary>
[NodeCategory("Web Assembly")]
public abstract class BaseWebAssemblyNode<C> : ExecutionNode<C>, IWebAssemblyNode<C> where C : ExecutionContext
{
#pragma warning disable CS8618 // Initializer generated by FluxWeaver

    /// <summary>A reference to the WebAssembly function to call if the signature matches.</summary>
    public readonly GlobalRef<FunctionExport?> FunctionExport;

#pragma warning restore CS8618

    // The object stores are required to ensure that this node gets properly cleaned up
    // since ProtoFlux nodes are not IDisposable, which woule let the not unregister
    // its OnFunctionChanged listener.

    public override void GlobalChanged<T>(int index, T value, C context)
    {
        //UniLog.Log($"{GetType()} GlobalChanged {typeof(T)}, {index}, {value}");
        base.GlobalChanged(index, value, context);
    }

    private ObjectStore<FunctionExport?> _registered;
    private ObjectStore<Action<FunctionExport?>> _handler;
    public void OnFunctionExportChanged(FunctionExport? newFunction, ExecutionContext ctx)
    {
        UniLog.Log($"{GetType()} OnFunctionChanged '{newFunction?.Name}'");
        var currentFunction = _registered.Read(ctx);
        if (currentFunction == newFunction) return;

        if (currentFunction is not null)
        {
            currentFunction.OnFunctionChanged -= _handler.Read(ctx);
        }

        if (newFunction is null)
        {
            _registered.Clear(ctx);
            _handler.Clear(ctx);
            return;
        }

        void handler(FunctionExport? func)
        {
            //UniLog.Log($"{GetType()} OnFunctionChange handler '{func?.Name}'");
            TrySetFunction(func?.Function);
        }
        newFunction.OnFunctionChanged += handler;
        handler(newFunction);
        _registered.Write(newFunction, ctx);
        _handler.Write(handler, ctx);
    }

    /// <inheritdoc/>
    public abstract FunctionSignature Signature { get; }

    /// <summary>
    /// Sets the delegate which is used by the JIT-compiled class, if possible.
    /// </summary>
    protected abstract void InternalSetDelegate(Delegate? @delegate);

    /// <inheritdoc/>
    public bool TrySetFunction(Wasmtime.Function? func)
    {
        UniLog.Log($"Try set function {func} on {Signature}");
        if (func is null)
        {
            InternalSetDelegate(null);
            return true;
        }
        var @delegate = Signature.TryCreateDelegate(func);
        UniLog.Log($"Delegate: {@delegate}");
        if (@delegate is null) return false;
        InternalSetDelegate(@delegate);
        return true;
    }
}