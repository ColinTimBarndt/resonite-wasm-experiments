using System;
using Elements.Core;
using FrooxEngine.ProtoFlux;
using Plugin.Wasm.Components;
using ProtoFlux.Core;
using ProtoFlux.Runtimes.Execution;

namespace Plugin.Wasm.ProtoFlux;

using FunctionExport = WebAssemblyInstance.FunctionExport;
using WasmFunction = Wasmtime.Function;

/// <summary>
/// A base class for all JIT-compiled WebAssembly Action ProtoFlux nodes.
/// </summary>
[NodeCategory("Web Assembly")]
public abstract class WebAssemblyAction : ActionBreakableFlowNode<ExecutionContext>, IWebAssemblyNode
{
#pragma warning disable CS8618 // Initializer generated by FluxWeaver

    /// <summary>A reference to the WebAssembly function to call if the signature matches.</summary>
    public readonly GlobalRef<FunctionExport?> Function;

#pragma warning restore CS8618

    // The object stores are required to ensure that this node gets properly cleaned up
    // since ProtoFlux nodes are not IDisposable, which woule let the not unregister
    // its OnFunctionChanged listener.

    private ObjectStore<FunctionExport> _registered;
    private ObjectStore<Action<FunctionExport>> _handler;
    private void OnFunctionChanged(FunctionExport? newFunction, FrooxEngineContext ctx)
    {
        UniLog.Log($"OnFunctionChanged '{newFunction?.Name}'");
        var currentFunction = _registered.Read(ctx);
        if (currentFunction == newFunction) return;

        if (currentFunction is not null)
        {
            currentFunction.OnFunctionChanged -= _handler.Read(ctx);
        }

        if (newFunction is null)
        {
            _registered.Clear(ctx);
            _handler.Clear(ctx);
            return;
        }

        var handler = (FunctionExport func) =>
        {
            TrySetFunction(func?.Function);
        };
        newFunction.OnFunctionChanged += handler;
        handler(newFunction);
        _registered.Write(newFunction, ctx);
        _handler.Write(handler, ctx);
    }

    /// <inheritdoc/>
    public abstract FunctionSignature Signature { get; }

    /// <summary>
    /// Sets the delegate which is used by the JIT-compiled class.
    /// The method does not ensure that the <paramref name="delegate"/>
    /// is of the correct type.
    /// </summary>
    protected abstract void InternalSetDelegate(Delegate? @delegate);

    /// <inheritdoc/>
    public bool TrySetFunction(Wasmtime.Function? func)
    {
        UniLog.Log($"Try set function {func} on {Signature}");
        if (func is null)
        {
            InternalSetDelegate(null);
            return true;
        }
        var @delegate = Signature.TryCreateDelegate(func);
        UniLog.Log($"Delegate: {@delegate}");
        if (@delegate is null) return false;
        InternalSetDelegate(@delegate);
        return true;
    }
}
