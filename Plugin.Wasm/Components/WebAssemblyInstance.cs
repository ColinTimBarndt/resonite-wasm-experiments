using System;
using System.Collections.Generic;
using Elements.Core;
using FrooxEngine;

namespace Plugin.Wasm.Components;

/// <summary>
/// A WebAssembly module instance, loaded from a provided module asset.
/// </summary>
[Category(["Web Assembly"])]
public sealed class WebAssemblyInstance : Component
{
#pragma warning disable CS8618 // Initializer generated by Resonite

    // Fields

    /// <summary>If the module asset has been loaded.</summary>
    public readonly RawOutput<bool> IsLoaded;

    /// <summary>The module asset to instantiate.</summary>
    public readonly AssetRef<WebAssemblyModule> Module;

    /// <summary>All function exports of the module instance.</summary>
    public readonly SyncBag<FunctionExport> FunctionExports;

#pragma warning restore CS8618

    // Local state
    private Wasmtime.Store? Store;
    private Wasmtime.Instance? Instance;
    private WeakReference<Wasmtime.Module>? InstanceModule;
    private bool _exportNamesDirty = false;

    /// <inheritdoc/>
    protected override void OnChanges()
    {
        var module = Module.Asset?.WasmModule;
        UpdateInstance(module);

        if (_exportNamesDirty && Instance is not null)
        {
            _exportNamesDirty = false;
            foreach (var export in FunctionExports.Values)
            {
                export.Function = Instance.GetFunction(export.ExportName);
            }
        }
    }

    private void UpdateInstance(Wasmtime.Module? module)
    {
        if (module is null)
        {
            if (Instance is null) return;
            Instance = null;
            InstanceModule = null;
            IsLoaded.Value = false;
            UpdateExports();
            Store?.Dispose();
            Store = null;
            return;
        }
        if (InstanceModule is null
            || !InstanceModule.TryGetTarget(out var instanceModule)
            || instanceModule != module
        )
        {
            // The referenced module has changed
            if (TryLoadModule(module))
                UpdateExports();
        }
    }

    private bool TryLoadModule(Wasmtime.Module module)
    {
        var engine = WasmEngineProvider.Engine;
        var newStore = new Wasmtime.Store(engine);
        try
        {
            Instance = new Wasmtime.Instance(newStore, module, []);
            Store = newStore;
            InstanceModule = new(module);
            newStore = null;
            IsLoaded.Value = true;
            UniLog.Log("Loaded WASM Module");
            return true;
        }
        catch (Wasmtime.WasmtimeException)
        {
            return false;
        }
        finally
        {
            newStore?.Dispose();
        }
    }

    /// <inheritdoc/>
    protected override void SyncMemberChanged(IChangeable member)
    {
        if (member is Sync<string> && member.Parent is FunctionExport)
        {
            _exportNamesDirty = true;
        }
        base.SyncMemberChanged(member);
    }

    private void UpdateExports()
    {
        _exportNamesDirty = false;
        var inst = Instance;
        if (inst is null)
        {
            foreach (var export in FunctionExports.Values)
                export.Function = null;
            return;
        }

        HashSet<string> Visited = [];

        foreach (var export in FunctionExports.Values)
        {
            var name = export.ExportName;
            var func = inst.GetFunction(name);
            if (func is null) continue;
            Visited.Add(name);
            export.Function = func;
        }

        // Add missing exports
        foreach (var exportFunc in inst.GetFunctions())
        {
            if (Visited.Contains(exportFunc.Name)) continue;

            var exportMember = FunctionExports.Add();
            exportMember.ExportName.Value = exportFunc.Name;
            exportMember.Function = exportFunc.Function;
        }
    }

    /// <summary>
    /// Represents an export from the parent WebAssembly instance.
    /// </summary>
    public abstract class Export : SyncObject
    {
#pragma warning disable CS8618 // Initializer generated by Resonite

        /// <summary>
        /// The name of the export.
        /// </summary>
        public readonly Sync<string> ExportName;

        /// <summary>
        /// Whether the export exists on the module, if one is loaded.
        /// </summary>
        public readonly RawOutput<bool> Exists;

#pragma warning restore CS8618

        /// <inheritdoc/>
        public override string Name => ExportName ?? "";
    }

    /// <summary>
    /// Represents an exported function from the parent WebAssembly instance.
    /// </summary>
    public class FunctionExport : Export
    {
        /// <summary>
        /// The function signature of the module export.
        /// It is explicitly not a sync member because it
        /// depends on the loaded WebAssembly module.
        /// </summary>
        public FunctionSignature Signature { get; private set; } = FunctionSignature.EMPTY;

        /// <inheritdoc/>
        public override string Name => $"{base.ExportName} {Signature}";

        private Wasmtime.Function? _function;

        /// <summary>
        /// An exported function, if the instance has a function export with a matching name.
        /// </summary>
        public Wasmtime.Function? Function
        {
            get => _function;
            internal set
            {
                if (_function == value) return;
                Exists.Value = value is not null;
                _function = value;
                if (value is null)
                {
                    Signature = FunctionSignature.EMPTY;
                }
                else
                {
                    Signature = new FunctionSignature(in value);
                }
                OnFunctionChanged?.Invoke(this);
            }
        }

        /// <summary>
        /// Fired whenever the Function field changes.
        /// </summary>
        public event Action<FunctionExport>? OnFunctionChanged;

        /// <inheritdoc/>
        public override DataTreeNode Save(SaveControl control)
        {
            var dict = (DataTreeDictionary)base.Save(control)!;
            dict.Add(nameof(Signature), Signature.Save(control));
            return dict;
        }

        /// <inheritdoc/>
        public override void Load(DataTreeNode node, LoadControl control)
        {
            base.Load(node, control);
            var dict = (DataTreeDictionary)node!;
            var sigTree = dict.TryGetNode(nameof(Signature));
            if (sigTree is not null) Signature = FunctionSignature.Load(sigTree, control);
            else Signature = FunctionSignature.EMPTY;
        }
    }
}
