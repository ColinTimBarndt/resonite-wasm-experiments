using System;
using System.Collections.Generic;
using Elements.Core;
using FrooxEngine;

namespace Plugin.Wasm.Components;

/// <summary>
/// A WebAssembly module instance, loaded from a provided module asset.
/// </summary>
[Category(["Web Assembly"])]
public sealed class WebAssemblyInstance : Component
{
#pragma warning disable CS8618 // Initializer generated by Resonite

    // Fields

    /// <summary>If the module asset has been loaded.</summary>
    public readonly RawOutput<bool> IsLoaded;

    /// <summary>The module asset to instantiate.</summary>
    public readonly AssetRef<WebAssemblyModule> Module;

    /// <summary>All function exports of the module instance.</summary>
    public readonly SyncBag<FunctionExport> FunctionExports;

#pragma warning restore CS8618

    // Local state
    private Wasmtime.Store? Store;
    private Wasmtime.Instance? Instance;
    private WebAssemblyModule? _currentInstanceModule;
    private bool _exportNamesDirty;
    private bool _instanceDirty;

    /// <inheritdoc/>
    protected override void OnChanges()
    {
        var asset = Module.Asset;
        if (asset != _currentInstanceModule)
        {
            if (_currentInstanceModule is not null)
                _currentInstanceModule.OnModuleChanged -= OnModuleChanged;
            _currentInstanceModule = asset;
            if (_currentInstanceModule is not null)
                _currentInstanceModule.OnModuleChanged += OnModuleChanged;
            _instanceDirty = true;
        }

        if (_instanceDirty)
        {
            _instanceDirty = false;
            UpdateInstance(_currentInstanceModule?.WasmModule);
        }

        if (_exportNamesDirty && Instance is not null)
        {
            _exportNamesDirty = false;
            foreach (var export in FunctionExports.Values)
            {
                string? name = export.ExportName;
                export.Function = name is null ? null : Instance.GetFunction(name);
            }
        }
    }

    private void OnModuleChanged(WebAssemblyModule newModule)
    {
        RunSynchronously(() =>
        {
            _instanceDirty = true;
            MarkChangeDirty();
        });
    }

    private void UpdateInstance(Wasmtime.Module? module)
    {
        if (module is null)
        {
            if (Instance is null) return;
            Instance = null;
            IsLoaded.Value = false;
            UpdateExports();
            Store?.Dispose();
            Store = null;
            return;
        }
        if (TryLoadModule(module))
            UpdateExports();
    }

    private bool TryLoadModule(Wasmtime.Module module)
    {
        var engine = WasmEngineProvider.Engine;
        var newStore = new Wasmtime.Store(engine, new StoreData());
        try
        {
            Instance = WasmLinkerProvider.Linker.Instantiate(newStore, module);
            var memory = Instance.GetMemory("memory");
            if (memory is not null)
            {
                var data = (StoreData)newStore.GetData()!;
                data.Memory = memory;
            }
            Store?.Dispose();
            Store = newStore;
            newStore = null;
            IsLoaded.Value = true;
            //Debug.Log("Created new WebAssembly Instance");
            return true;
        }
        catch (Wasmtime.WasmtimeException)
        {
            return false;
        }
        finally
        {
            newStore?.Dispose();
        }
    }

    /// <inheritdoc/>
    protected override void SyncMemberChanged(IChangeable member)
    {
        if (member is Sync<string> && member.Parent is FunctionExport)
        {
            _exportNamesDirty = true;
        }
        base.SyncMemberChanged(member);
    }

    private void UpdateExports()
    {
        _exportNamesDirty = false;
        var inst = Instance;
        if (inst is null)
        {
            foreach (var export in FunctionExports.Values)
                export.Function = null;
            return;
        }

        HashSet<string> Visited = Pool.BorrowHashSet<string>();

        foreach (var export in FunctionExports.Values)
        {
            string? name = export.ExportName;
            if (name is null) continue;
            var func = inst.GetFunction(name);
            if (func is null) continue;
            Visited.Add(name);
            export.Function = func;
        }

        // Add missing exports
        foreach (var exportFunc in inst.GetFunctions())
        {
            if (Visited.Contains(exportFunc.Name)) continue;

            var exportMember = FunctionExports.Add();
            exportMember.ExportName.Value = exportFunc.Name;
            exportMember.Function = exportFunc.Function;
        }

        Pool.Return(ref Visited);
    }

    /// <inheritdoc/>
    protected override void OnDispose()
    {
        if (_currentInstanceModule is not null)
            _currentInstanceModule.OnModuleChanged -= OnModuleChanged;
        base.OnDispose();
    }

    /// <summary>
    /// Removes all exports which don't exist on the current instance.
    /// </summary>
    [SyncMethod(typeof(Action))]
    public void RemoveEmptyExports()
    {
        foreach (var export in FunctionExports.Values)
        {
            if (export.Exists) continue;
            FunctionExports.Remove(export);
        }
    }

    /// <summary>
    /// Gets a named function export from the current instance.
    /// </summary>
    [SyncMethod(typeof(Func<string, FunctionExport?>))]
    public FunctionExport? GetFunctionExport(string name)
    {
        foreach (var export in FunctionExports.Values)
        {
            if (export.ExportName == name) return export;
        }
        return null;
    }

    /// <summary>
    /// Represents an export from the parent WebAssembly instance.
    /// </summary>
    public abstract class Export : SyncObject
    {
#pragma warning disable CS8618 // Initializer generated by Resonite

        /// <summary>
        /// The name of the export.
        /// </summary>
        public readonly Sync<string?> ExportName;

        /// <summary>
        /// Whether the export exists on the module, if one is loaded.
        /// </summary>
        public readonly RawOutput<bool> Exists;

#pragma warning restore CS8618

        /// <inheritdoc/>
        public override string Name => (string?)ExportName ?? "";
    }

    /// <summary>
    /// Represents an exported function from the parent WebAssembly instance.
    /// </summary>
    public class FunctionExport : Export
    {
        /// <summary>
        /// The function signature of the module export.
        /// It is explicitly not a sync member because it
        /// depends on the loaded WebAssembly module.
        /// </summary>
        public FunctionSignature Signature { get; private set; } = FunctionSignature.EMPTY;

        /// <inheritdoc/>
        public override string Name => $"{base.ExportName} {Signature}";

        private Wasmtime.Function? _function;

        /// <summary>
        /// An exported function, if the instance has a function export with a matching name.
        /// </summary>
        public Wasmtime.Function? Function
        {
            get => _function;
            internal set
            {
                if (_function == value) return;
                Exists.Value = value is not null;
                _function = value;
                if (value is null)
                {
                    Signature = FunctionSignature.EMPTY;
                }
                else
                {
                    Signature = new FunctionSignature(in value);
                }
                //Debug.Log("FunctionExport OnFunctionChanged");
                OnFunctionChanged?.Invoke(this);
            }
        }

        /// <summary>
        /// Fired whenever the Function field changes.
        /// </summary>
        public event Action<FunctionExport>? OnFunctionChanged;

        /// <inheritdoc/>
        protected override void OnDispose()
        {
            Function = null;
            base.OnDispose();
        }

        /// <inheritdoc/>
        public override DataTreeNode Save(SaveControl control)
        {
            var dict = (DataTreeDictionary)base.Save(control)!;
            dict.Add(nameof(Signature), Signature.Save(control));
            return dict;
        }

        /// <inheritdoc/>
        public override void Load(DataTreeNode node, LoadControl control)
        {
            base.Load(node, control);
            var dict = (DataTreeDictionary)node!;
            var sigTree = dict.TryGetNode(nameof(Signature));
            if (sigTree is not null) Signature = FunctionSignature.Load(sigTree, control);
            else Signature = FunctionSignature.EMPTY;
        }
    }
}
